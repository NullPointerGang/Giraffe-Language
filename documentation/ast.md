# Документация для абстрактного синтаксического дерева (AST)

Абстрактное синтаксическое дерево (AST) — это иерархическое представление структуры исходного кода. Оно используется для представления синтаксической структуры кода в более удобном для обработки виде. Эта документация описывает основные компоненты AST, их связи и поля.

## Обзор

AST состоит из трех основных компонентов:

- **AstNode**: Представляет корневой узел AST.
- **Statement**: Представляет различные типы операторов, которые выполняются в программе.
- **Expression**: Представляет выражения, используемые в операторах и вычислениях.

### AstNode

Перечисление `AstNode` является корневым узлом AST и содержит структуру программы с операторами.

#### Варианты:

- `Program { statements: Vec<Statement> }`:
  - Представляет всю программу, состоящую из списка операторов.
- `Statement(Statement)`:
  - Содержит один оператор, который является частью программы.
- `Expression(Expression)`:
  - Содержит выражение, которое может быть частью оператора или отдельным элементом.

#### Методы:
- `build_program(statements: Vec<Statement>) -> AstNode`: 
  - Создает узел `Program` с набором операторов.

### Statement

Перечисление `Statement` представляет различные типы операторов в программе. Операторы выполняются и обычно выполняют действие в программе.

#### Варианты:

- `FunctionDeclaration(FunctionDeclaration)`:
  - Представляет объявление функции в программе.
- `VariableDeclaration(VariableDeclaration)`:
  - Представляет объявление переменной.
- `IfStatement(IfStatement)`:
  - Представляет оператор if с условием, телом и опциональными ветвями elif и else.
- `WhileStatement(WhileStatement)`:
  - Представляет оператор while с условием и телом.
- `PrintStatement(PrintStatement)`:
  - Представляет оператор вывода (print).
- `ReturnStatement(ReturnStatement)`:
  - Представляет оператор возврата.
- `Assignment(Assignment)`:
  - Представляет оператор присваивания, который присваивает значение переменной.
- `ExpressionStatement(Expression)`:
  - Представляет оператор, который является выражением (без побочных эффектов).
- `Block(Vec<Statement>)`:
  - Представляет блок операторов.
- `ForInStatement(String, Expression, Vec<Statement>)`:
  - Представляет цикл `for`, который перебирает коллекцию.

#### Методы:
- Доступны различные методы для создания конкретных типов операторов, таких как `function_declaration()`, `variable_declaration()`, `if_statement()` и др.

### Expression

Перечисление `Expression` представляет выражения, которые вычисляются для получения значения. Оно используется как часть операторов или в расчетах.

#### Варианты:

- `Literal(Literal)`:
  - Представляет литеральное значение, такое как числа, строки, булевы значения и т. д.
- `Variable(String)`:
  - Представляет переменную (то есть ссылку на переменную по имени).
- `BinaryOperation(Box<Expression>, Operator, Box<Expression>)`:
  - Представляет бинарную операцию с левым операндом, оператором и правым операндом.
- `FunctionCall(String, Vec<Expression>)`:
  - Представляет вызов функции с именем функции и списком аргументов.
- `List(Vec<Expression>)`:
  - Представляет список выражений.
- `Dictionary(Vec<(Expression, Expression)>)`:
  - Представляет словарь с парами ключ-значение, где как ключи, так и значения являются выражениями.
- `Tuple(Vec<Expression>)`:
  - Представляет кортеж из выражений.
- `Null`:
  - Представляет значение null.

#### Методы:
- Доступны различные методы для создания выражений, такие как `literal()`, `variable()`, `binary_operation()`, `function_call()` и др.

### Literal

Перечисление `Literal` представляет литеральные значения, которые могут быть использованы напрямую в исходном коде.

#### Варианты:

- `Integer(i64)`:
  - Представляет литеральное целое число.
- `Float(f64)`:
  - Представляет литеральное число с плавающей запятой.
- `Boolean(bool)`:
  - Представляет литеральное булево значение (`true` или `false`).
- `String(String)`:
  - Представляет литеральную строку.
- `Null`:
  - Представляет значение null.

### Operator

Перечисление `Operator` представляет различные операторы, которые могут быть использованы в выражениях, такие как арифметические и операторы сравнения.

#### Варианты:

- `Add`: Сложение (`+`)
- `Subtract`: Вычитание (`-`)
- `Multiply`: Умножение (`*`)
- `Divide`: Деление (`/`)
- `GreaterThan`: Больше чем (`>`)
- `LessThan`: Меньше чем (`<`)
- `Equal`: Равно (`==`)
- `NotEqual`: Не равно (`!=`)
- `And`: Логическое И (`&&`)
- `Or`: Логическое ИЛИ (`||`)

#### Методы:
- Доступны различные методы для создания операторов, такие как `add()`, `subtract()`, `multiply()` и др.

### TokenType

Перечисление `TokenType` представляет типы токенов, которые распознаются лексером. Это перечисление используется в процессе лексического анализа для классификации элементов кода.

#### Варианты:

- `COMMENT_MULTILINE`, `COMMENT_SINGLELINE`: Представляют комментарии.
- `KEYWORD`: Представляет ключевое слово.
- `IDENTIFIER`: Представляет идентификатор.
- `INTEGER`, `FLOAT`, `STRING`, `BOOLEAN`: Представляют примитивные типы.
- `LIST`, `DICT`, `SET`, `TUPLE`: Представляют сложные типы данных.
- `NULL`, `OPTION`: Представляют специальные типы.
- `ERROR`: Представляет нераспознанный токен.
- `FUNCTION`: Представляет функцию.
- `OPERATOR`, `SYMBOL`, `BRACKET`, `PUNCTUATION`: Представляют операторы, символы и знаки препинания.
- `PRINT`: Представляет оператор вывода (print).
- `EOF`: Представляет конец файла.

### Token

Структура `Token` представляет токен в исходном коде. Каждый токен имеет тип (из `TokenType`) и значение (строку, которое этот токен представляет).

#### Поля:
- `token_type`: Тип токена (из `TokenType`).
- `value`: Строковое значение токена.

#### Методы:
- `new(token_type: TokenType, value: &str) -> Self`: Создает новый токен с заданным типом и значением.

## Заключение

В этой документации описана структура абстрактного синтаксического дерева (AST), которое используется для представления исходного кода в виде иерархической модели. Мы рассмотрели основные компоненты AST, такие как узлы программы, операторы и выражения, а также различные типы данных, которые могут быть использованы в процессе анализа и выполнения программы.